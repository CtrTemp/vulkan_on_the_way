
// 第一步编写 VertexShader
// Vertex Shader 中的语法与C语言基本一致
/*
    之前提到，Vertex Shader 对读入的顶点进行操作，主要功能是坐标变换，
通过矩阵操作将所有顶点从其相对坐标系变换到世界坐标系中。
    由于我们在此进行最基本的简单三角形面元的渲染，故省略来三角形网格细分
的一切相关步骤，所以顶点着色器的输出将直接输入到光栅化器之中。

    这里对我们的三角形坐标做一个说明，在这里定义的三角形坐标是预定义的，
并非由计算得出，直接是映射后应该得到的归一化坐标，纵横的range都是-1～1。
对应屏幕中心的坐标为（0,0），左上角为（-1,-1），右下角为（1,1）。
    （特别说明，这里的坐标定义y轴的正负方向与OpenGL的定义是相反的）
*/ 
#version 450

layout(location = 0) out vec3 fragColor;

// 这里预定义三角形的坐标，在非文件读入的时候，我们就这样做
vec2 positions[3] = vec2[](
    vec2(0.0, -0.5),
    vec2(0.5, 0.5),
    vec2(-0.5, 0.5)
);

/*
    如果你想让你的三角形的每个顶点有不同的颜色，我们同样可以通过预定义的方式来确定其颜色。
这里我们将三个顶点刚好置为 R/G/B 全色
    其实这里的颜色值应该也可以从文件读入
*/ 
vec3 colors[3] = vec3[](
    vec3(1.0, 0.0, 0.0),
    vec3(0.0, 1.0, 0.0),
    vec3(0.0, 0.0, 1.0)
);


/*
    在 vertex shader 中，每个顶点都会调用一次main()函数！这是在GPU中内置并行的部分。
    其中 gl_Position 为内置变量，用作管线中当前组件的输出，gl_VertexIndex也是内置
变量，用于指示当前顶点的索引。
    可以看到，GLSL语言中允许使用这种插入拼接的方式来从低维数组创建高维数组，其中gl_Position
的第三个维度代表其深度坐标，这里我们就将其置为0，不考虑任何三角形的深度（因为目前只渲染一个）。
第四维度代表不对坐标做任何变换直接输出。
*/ 

void main() {
    // 这里应该是直接输出，最后一个维度值设为1表示当其转化为标准设备输出（-1～1）的过程中不会改变任何内容。
    gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0);
    // 这里的 fragColor 也是内置变量，将对应顶点的颜色结果传入即可，同样通过内置变量gl_VertexIndex
    // 给出顶点索引
    fragColor = colors[gl_VertexIndex];
}